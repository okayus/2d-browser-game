/**
 * 日時処理ユーティリティ単体テスト
 * 
 * 初学者向けメモ：
 * - ISO8601形式での日時処理の確認
 * - 日本語フォーマットの動作検証
 * - 相対時間表示の正確性確認
 * - エラーハンドリングの検証
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  現在日時取得,
  日時文字列をDate変換,
  日時を日本語でフォーマット,
  相対日時表示
} from '../../utils/date-utils';

describe('日時処理ユーティリティ単体テスト', () => {
  /**
   * 各テスト前の初期化
   * 
   * 初学者向けメモ：
   * - タイマーをリアルタイマーに戻して各テストの独立性を保つ
   * - モックされた時刻をクリア
   */
  beforeEach(() => {
    vi.useRealTimers();
    vi.clearAllMocks();
  });

  describe('現在日時取得関数', () => {
    /**
     * 正常系テスト: ISO8601形式での出力確認
     * 
     * 初学者向けメモ：
     * - ISO8601形式の正規表現パターンで検証
     * - UTCタイムゾーンでの出力確認
     * - 文字列長と形式の確認
     */
    it('ISO8601形式で現在日時を返す', () => {
      const 現在日時 = 現在日時取得();
      
      // ISO8601形式の正規表現パターン
      const iso8601Pattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;
      
      expect(現在日時).toMatch(iso8601Pattern);
      expect(現在日時).toMatch(/T/); // 日付と時刻の区切り文字
      expect(現在日時).toMatch(/Z$/); // UTCタイムゾーンを示すZ
    });

    /**
     * 時刻の一貫性テスト: 連続呼び出しでの時刻進行確認
     * 
     * 初学者向けメモ：
     * - 連続呼び出しで時刻が進むことを確認
     * - 同一ミリ秒内でも同じ時刻が返されることを確認
     */
    it('連続で呼び出すと時刻が進行する', async () => {
      const 時刻1 = 現在日時取得();
      
      // 少し待つ
      await new Promise(resolve => setTimeout(resolve, 10));
      
      const 時刻2 = 現在日時取得();
      
      expect(new Date(時刻2).getTime()).toBeGreaterThanOrEqual(new Date(時刻1).getTime());
    });

    /**
     * パース可能性テスト: 生成された文字列がDateオブジェクトに変換可能
     */
    it('生成された日時文字列がDateオブジェクトに変換可能', () => {
      const 日時文字列 = 現在日時取得();
      const 日付オブジェクト = new Date(日時文字列);
      
      expect(日付オブジェクト).toBeInstanceOf(Date);
      expect(isNaN(日付オブジェクト.getTime())).toBe(false);
    });

    /**
     * 時刻精度テスト: ミリ秒精度での確認
     */
    it('ミリ秒精度で時刻を取得する', () => {
      const 日時文字列 = 現在日時取得();
      
      // ミリ秒部分の確認（最後の4文字が .xxxZ の形式）
      expect(日時文字列).toMatch(/\.\d{3}Z$/);
    });
  });

  describe('日時文字列をDate変換関数', () => {
    /**
     * 正常系テスト: 有効な日時文字列の変換
     * 
     * 初学者向けメモ：
     * - 様々な有効な日時形式での変換確認
     * - ISO8601以外の一般的な形式も含む
     */
    it('有効な日時文字列をDateオブジェクトに変換する', () => {
      const 有効な日時文字列一覧 = [
        '2025-07-06T10:30:45.123Z',      // ISO8601 with milliseconds
        '2025-07-06T10:30:45Z',          // ISO8601 without milliseconds
        '2025-07-06T10:30:45+09:00',     // ISO8601 with timezone
        '2025-07-06 10:30:45',           // SQL datetime format
        '2025/07/06 10:30:45',           // Japanese format
        'July 6, 2025 10:30:45',         // English format
      ];

      有効な日時文字列一覧.forEach(日時文字列 => {
        const 結果 = 日時文字列をDate変換(日時文字列);
        
        expect(結果).toBeInstanceOf(Date);
        expect(isNaN(結果.getTime())).toBe(false);
        
        // 2025年であることを確認
        expect(結果.getFullYear()).toBe(2025);
      });
    });

    /**
     * 異常系テスト: 無効な日時文字列
     * 
     * 初学者向けメモ：
     * - 無効な形式でのエラー確認
     * - 適切なエラーメッセージの確認
     */
    it('無効な日時文字列の場合はエラーを投げる', () => {
      const 無効な日時文字列一覧 = [
        'invalid date',
        '2025-13-45',        // 無効な月・日
        '2025-07-32',        // 無効な日
        '2025-07-06T25:00:00', // 無効な時刻
        '',                   // 空文字
        '日本語の日付',       // 数字以外
      ];

      無効な日時文字列一覧.forEach(無効な文字列 => {
        expect(() => {
          日時文字列をDate変換(無効な文字列);
        }).toThrow(`無効な日時形式です: ${無効な文字列}`);
      });
    });

    /**
     * 精度保持テスト: ミリ秒精度の保持確認
     */
    it('ミリ秒精度を正しく保持する', () => {
      const 元の日時 = new Date('2025-07-06T10:30:45.123Z');
      const 日時文字列 = 元の日時.toISOString();
      const 変換された日時 = 日時文字列をDate変換(日時文字列);
      
      expect(変換された日時.getTime()).toBe(元の日時.getTime());
      expect(変換された日時.getMilliseconds()).toBe(123);
    });

    /**
     * タイムゾーンテスト: 異なるタイムゾーンでの変換
     */
    it('異なるタイムゾーンの日時文字列を正しく変換する', () => {
      const UTC時刻 = '2025-07-06T10:30:45Z';
      const JST時刻 = '2025-07-06T19:30:45+09:00'; // UTC+9
      
      const UTC変換結果 = 日時文字列をDate変換(UTC時刻);
      const JST変換結果 = 日時文字列をDate変換(JST時刻);
      
      // 同じ瞬間を表すので、UTC時刻で比較すると同じになる
      expect(UTC変換結果.getTime()).toBe(JST変換結果.getTime());
    });
  });

  describe('日時を日本語でフォーマット関数', () => {
    /**
     * 正常系テスト: Dateオブジェクトのフォーマット
     * 
     * 初学者向けメモ：
     * - 日本語ロケールでの表示確認
     * - 年月日時分秒の形式確認
     */
    it('Dateオブジェクトを日本語形式でフォーマットする', () => {
      const テスト日時 = new Date('2025-07-06T14:30:45');
      const フォーマット結果 = 日時を日本語でフォーマット(テスト日時);
      
      // 日本語形式の基本構造確認
      expect(フォーマット結果).toMatch(/\d{4}\/\d{2}\/\d{2}/); // YYYY/MM/DD
      expect(フォーマット結果).toMatch(/\d{2}:\d{2}:\d{2}/);   // HH:MM:SS
      expect(フォーマット結果).toContain('2025');
      expect(フォーマット結果).toContain('07');
      expect(フォーマット結果).toContain('06');
    });

    /**
     * 正常系テスト: 日時文字列のフォーマット
     */
    it('日時文字列を日本語形式でフォーマットする', () => {
      const 日時文字列 = '2025-12-31T23:59:59.999Z';
      const フォーマット結果 = 日時を日本語でフォーマット(日時文字列);
      
      expect(フォーマット結果).toMatch(/\d{4}\/\d{2}\/\d{2}/);
      expect(フォーマット結果).toMatch(/\d{2}:\d{2}:\d{2}/);
      // タイムゾーン変換により年が変わる可能性があるため、基本的な形式のみ確認
    });

    /**
     * フォーマット一貫性テスト: 同じ時刻での一貫した出力
     */
    it('同じ時刻では常に同じフォーマット結果を返す', () => {
      const テスト日時 = new Date('2025-07-06T10:30:45');
      
      const 結果1 = 日時を日本語でフォーマット(テスト日時);
      const 結果2 = 日時を日本語でフォーマット(テスト日時);
      const 結果3 = 日時を日本語でフォーマット(テスト日時.toISOString());
      
      expect(結果1).toBe(結果2);
      expect(結果1).toBe(結果3);
    });

    /**
     * 特殊日付テスト: 境界値や特殊な日付での動作確認
     */
    it('特殊な日付でも正しくフォーマットする', () => {
      const 特殊日付一覧 = [
        new Date('2025-01-01T00:00:00'), // 年始
        new Date('2025-12-31T23:59:59'), // 年末
        new Date('2025-02-29T12:00:00'), // うるう年ではない年の2月29日（実際は3月1日になる）
        new Date('2000-02-29T12:00:00'), // うるう年の2月29日
      ];

      特殊日付一覧.forEach(日付 => {
        const 結果 = 日時を日本語でフォーマット(日付);
        expect(結果).toMatch(/\d{4}\/\d{2}\/\d{2} \d{2}:\d{2}:\d{2}/);
      });
    });
  });

  describe('相対日時表示関数', () => {
    /**
     * 正常系テスト: 「今」の表示
     * 
     * 初学者向けメモ：
     * - 現在時刻またはごく最近の時刻での「今」表示確認
     * - 60秒未満での動作確認
     */
    it('60秒未満の場合は「今」を返す', () => {
      // 現在時刻をモック
      const 現在時刻 = new Date('2025-07-06T10:30:45');
      vi.useFakeTimers();
      vi.setSystemTime(現在時刻);

      const テストケース = [
        { 差分秒: 0, 期待値: '今' },
        { 差分秒: 30, 期待値: '今' },
        { 差分秒: 59, 期待値: '今' },
      ];

      テストケース.forEach(({ 差分秒, 期待値 }) => {
        const 過去時刻 = new Date(現在時刻.getTime() - 差分秒 * 1000);
        const 結果 = 相対日時表示(過去時刻);
        expect(結果).toBe(期待値);
      });
    });

    /**
     * 正常系テスト: 分単位の表示
     */
    it('1時間未満の場合は「X分前」を返す', () => {
      const 現在時刻 = new Date('2025-07-06T10:30:45');
      vi.useFakeTimers();
      vi.setSystemTime(現在時刻);

      const テストケース = [
        { 差分分: 1, 期待値: '1分前' },
        { 差分分: 15, 期待値: '15分前' },
        { 差分分: 30, 期待値: '30分前' },
        { 差分分: 59, 期待値: '59分前' },
      ];

      テストケース.forEach(({ 差分分, 期待値 }) => {
        const 過去時刻 = new Date(現在時刻.getTime() - 差分分 * 60 * 1000);
        const 結果 = 相対日時表示(過去時刻);
        expect(結果).toBe(期待値);
      });
    });

    /**
     * 正常系テスト: 時間単位の表示
     */
    it('1日未満の場合は「X時間前」を返す', () => {
      const 現在時刻 = new Date('2025-07-06T10:30:45');
      vi.useFakeTimers();
      vi.setSystemTime(現在時刻);

      const テストケース = [
        { 差分時間: 1, 期待値: '1時間前' },
        { 差分時間: 6, 期待値: '6時間前' },
        { 差分時間: 12, 期待値: '12時間前' },
        { 差分時間: 23, 期待値: '23時間前' },
      ];

      テストケース.forEach(({ 差分時間, 期待値 }) => {
        const 過去時刻 = new Date(現在時刻.getTime() - 差分時間 * 60 * 60 * 1000);
        const 結果 = 相対日時表示(過去時刻);
        expect(結果).toBe(期待値);
      });
    });

    /**
     * 正常系テスト: 日単位の表示
     */
    it('30日未満の場合は「X日前」を返す', () => {
      const 現在時刻 = new Date('2025-07-06T10:30:45');
      vi.useFakeTimers();
      vi.setSystemTime(現在時刻);

      const テストケース = [
        { 差分日: 1, 期待値: '1日前' },
        { 差分日: 7, 期待値: '7日前' },
        { 差分日: 15, 期待値: '15日前' },
        { 差分日: 29, 期待値: '29日前' },
      ];

      テストケース.forEach(({ 差分日, 期待値 }) => {
        const 過去時刻 = new Date(現在時刻.getTime() - 差分日 * 24 * 60 * 60 * 1000);
        const 結果 = 相対日時表示(過去時刻);
        expect(結果).toBe(期待値);
      });
    });

    /**
     * 正常系テスト: 長期間の表示（日本語フォーマット）
     */
    it('30日以上の場合は日本語フォーマットを返す', () => {
      const 現在時刻 = new Date('2025-07-06T10:30:45');
      vi.useFakeTimers();
      vi.setSystemTime(現在時刻);

      const 長期間前 = new Date('2025-01-01T10:30:45'); // 約6ヶ月前
      const 結果 = 相対日時表示(長期間前);
      
      // 日本語フォーマットが返されることを確認
      expect(結果).toMatch(/\d{4}\/\d{2}\/\d{2}/);
      expect(結果).toMatch(/\d{2}:\d{2}:\d{2}/);
      expect(結果).toContain('2025');
      expect(結果).toContain('01');
    });

    /**
     * 文字列入力テスト: 日時文字列での動作確認
     */
    it('日時文字列を入力しても正しく動作する', () => {
      const 現在時刻 = new Date('2025-07-06T10:30:45');
      vi.useFakeTimers();
      vi.setSystemTime(現在時刻);

      const 過去時刻文字列 = '2025-07-06T10:25:45'; // 5分前
      const 結果 = 相対日時表示(過去時刻文字列);
      
      expect(結果).toBe('5分前');
    });

    /**
     * 境界値テスト: 各単位の境界での動作確認
     */
    it('時間単位の境界値で正しく動作する', () => {
      const 現在時刻 = new Date('2025-07-06T10:30:45');
      vi.useFakeTimers();
      vi.setSystemTime(現在時刻);

      // 境界値テスト
      const 境界値テストケース = [
        { 時刻: new Date(現在時刻.getTime() - 59 * 1000), 期待パターン: '今' },
        { 時刻: new Date(現在時刻.getTime() - 60 * 1000), 期待パターン: '1分前' },
        { 時刻: new Date(現在時刻.getTime() - 59 * 60 * 1000), 期待パターン: '59分前' },
        { 時刻: new Date(現在時刻.getTime() - 60 * 60 * 1000), 期待パターン: '1時間前' },
        { 時刻: new Date(現在時刻.getTime() - 23 * 60 * 60 * 1000), 期待パターン: '23時間前' },
        { 時刻: new Date(現在時刻.getTime() - 24 * 60 * 60 * 1000), 期待パターン: '1日前' },
      ];

      境界値テストケース.forEach(({ 時刻, 期待パターン }) => {
        const 結果 = 相対日時表示(時刻);
        expect(結果).toBe(期待パターン);
      });
    });

    /**
     * 未来日時テスト: 未来の日時での動作確認
     * 
     * 初学者向けメモ：
     * - 未来の日時では負の値になるため、適切に処理されることを確認
     * - 実装によっては未来日時の特別な処理が必要
     */
    it('未来の日時でも適切に処理する', () => {
      const 現在時刻 = new Date('2025-07-06T10:30:45');
      vi.useFakeTimers();
      vi.setSystemTime(現在時刻);

      const 未来時刻 = new Date(現在時刻.getTime() + 60 * 60 * 1000); // 1時間後
      const 結果 = 相対日時表示(未来時刻);
      
      // 未来の日時は日本語フォーマットまたは特別な表示になる
      // 実装に依存するため、エラーにならないことを確認
      expect(typeof 結果).toBe('string');
      expect(結果.length).toBeGreaterThan(0);
    });
  });

  describe('統合テスト', () => {
    /**
     * ワークフローテスト: 一連の日時処理の流れ
     * 
     * 初学者向けメモ：
     * - 実際のアプリケーションでの使用パターンを模擬
     * - 関数間の連携確認
     */
    it('日時処理の一連のワークフローが正しく動作する', () => {
      // 1. 現在日時を取得
      const 現在日時文字列 = 現在日時取得();
      
      // 2. 文字列をDateオブジェクトに変換
      const 現在日時オブジェクト = 日時文字列をDate変換(現在日時文字列);
      
      // 3. 日本語でフォーマット
      const 日本語表示 = 日時を日本語でフォーマット(現在日時オブジェクト);
      
      // 4. 相対時間表示
      const 相対表示 = 相対日時表示(現在日時オブジェクト);
      
      // 全ての処理が成功することを確認
      expect(現在日時文字列).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
      expect(現在日時オブジェクト).toBeInstanceOf(Date);
      expect(日本語表示).toMatch(/\d{4}\/\d{2}\/\d{2} \d{2}:\d{2}:\d{2}/);
      expect(相対表示).toBe('今');
    });

    /**
     * データベース保存・表示パターンテスト
     */
    it('データベース保存から表示までの実用パターンが動作する', () => {
      // データベース保存用の日時生成
      const 保存用日時 = 現在日時取得();
      
      // データベースから取得した想定で変換
      const 取得した日時 = 日時文字列をDate変換(保存用日時);
      
      // ユーザー向け表示の生成
      const 詳細表示 = 日時を日本語でフォーマット(取得した日時);
      const 簡易表示 = 相対日時表示(取得した日時);
      
      expect(詳細表示).toMatch(/\d{4}\/\d{2}\/\d{2} \d{2}:\d{2}:\d{2}/);
      expect(簡易表示).toBe('今');
      
      // 元の日時が保持されていることを確認
      expect(取得した日時.toISOString()).toBe(保存用日時);
    });

    /**
     * タイムゾーン考慮テスト: JSTでの一貫した動作
     */
    it('日本時間での一貫した動作を確認する', () => {
      // UTC時刻でのテスト
      const UTC日時 = '2025-07-06T01:30:45Z';
      const JST日時 = '2025-07-06T10:30:45+09:00';
      
      const UTC変換 = 日時文字列をDate変換(UTC日時);
      const JST変換 = 日時文字列をDate変換(JST日時);
      
      // 同じ瞬間を表すことを確認
      expect(UTC変換.getTime()).toBe(JST変換.getTime());
      
      // 日本語フォーマットでも同じ結果
      const UTCフォーマット = 日時を日本語でフォーマット(UTC変換);
      const JSTフォーマット = 日時を日本語でフォーマット(JST変換);
      expect(UTCフォーマット).toBe(JSTフォーマット);
    });
  });
});

/**
 * 初学者向けメモ：日時処理テストのポイント
 * 
 * 1. 形式検証
 *    - ISO8601形式の正確性確認
 *    - 正規表現による構造チェック
 *    - 日本語表示形式の一貫性
 * 
 * 2. 精度確認
 *    - ミリ秒精度の保持
 *    - 変換前後での値の保持
 *    - 丸め誤差の確認
 * 
 * 3. タイムゾーン処理
 *    - UTC時刻での統一管理
 *    - ローカル時刻での表示
 *    - タイムゾーン変換の正確性
 * 
 * 4. 境界値テスト
 *    - 相対時間の境界（59秒→1分など）
 *    - うるう年、月末日の処理
 *    - 特殊な日付での動作
 * 
 * 5. エラーハンドリング
 *    - 無効な日時文字列の処理
 *    - 適切なエラーメッセージ
 *    - 例外安全性の確保
 * 
 * 6. 実用性確認
 *    - データベース保存・取得パターン
 *    - ユーザーインターフェース表示
 *    - APIレスポンスでの使用
 * 
 * 7. 一貫性確認
 *    - 同じ入力での同じ出力
 *    - 関数間での値の整合性
 *    - 文字列⇔Dateオブジェクトの相互変換
 */