/**
 * ロガーユーティリティ
 * 
 * 初学者向けメモ：
 * - console.log の直接使用を避け、統一されたログシステムを提供
 * - 本番環境とデバッグ環境でログ出力を制御
 * - ログレベルによる分類で問題の特定を効率化
 * - 構造化ログの基礎として設計
 */

/**
 * ログレベルの定義
 * 
 * 初学者向けメモ：
 * - const assertion で型を固定
 * - ログの重要度を数値で表現
 * - 将来的にログフィルタリングに使用可能
 */
const ログレベル = {
  デバッグ: 0,
  情報: 1,
  警告: 2,
  エラー: 3,
} as const;

/**
 * ログレベルの型定義
 * 
 * 初学者向けメモ：将来の機能拡張で使用予定
 */
// type ログレベル型 = typeof ログレベル[keyof typeof ログレベル];

/**
 * ログエントリの型定義
 * 
 * 初学者向けメモ：
 * - 構造化ログの基本形
 * - タイムスタンプ、レベル、メッセージを統一
 * - 将来的に外部ログシステムと連携しやすい形式
 */
interface ログエントリ {
  readonly タイムスタンプ: Date;
  readonly レベル: keyof typeof ログレベル;
  readonly メッセージ: string;
  readonly データ?: unknown;
  readonly エラー?: Error | undefined;
}

/**
 * 環境変数の取得
 * 
 * 初学者向けメモ：
 * - process.env.NODE_ENV は Node.js の標準的な環境変数
 * - 本番環境（production）、開発環境（development）、テスト環境（test）を区別
 */
const 環境 = process.env['NODE_ENV'] || 'development';
const 本番環境か = 環境 === 'production';

/**
 * ログフォーマッター
 * 
 * 初学者向けメモ：
 * - ログエントリを文字列に変換する関数
 * - 統一されたフォーマットでログを出力
 * - 本番環境では簡潔に、開発環境では詳細に
 */
function ログフォーマット(エントリ: ログエントリ): string {
  const 時刻文字列 = エントリ.タイムスタンプ.toISOString();
  const レベル文字列 = `[${エントリ.レベル}]`;
  
  let 基本メッセージ = `${時刻文字列} ${レベル文字列} ${エントリ.メッセージ}`;
  
  // 開発環境では追加情報も出力
  if (!本番環境か && エントリ.データ) {
    基本メッセージ += ` | データ: ${JSON.stringify(エントリ.データ)}`;
  }
  
  return 基本メッセージ;
}

/**
 * ロガーオブジェクト
 * 
 * 初学者向けメモ：
 * - 各ログレベルに対応したメソッドを提供
 * - ESLint のno-consoleルールを回避
 * - 将来的な機能拡張（ファイル出力、外部送信など）に対応可能
 */
export const ロガー = {
  /**
   * デバッグレベルのログ
   * 開発時のみ出力
   * 
   * @param メッセージ - ログメッセージ
   * @param データ - 追加データ（オプション）
   */
  デバッグ: (メッセージ: string, データ?: unknown): void => {
    if (本番環境か) return; // 本番環境では出力しない
    
    const エントリ: ログエントリ = {
      タイムスタンプ: new Date(),
      レベル: 'デバッグ',
      メッセージ,
      データ,
    };
    
    // eslint-disable-next-line no-console
    console.log(ログフォーマット(エントリ));
  },

  /**
   * 情報レベルのログ
   * 通常の動作状況を記録
   * 
   * @param メッセージ - ログメッセージ
   * @param データ - 追加データ（オプション）
   */
  情報: (メッセージ: string, データ?: unknown): void => {
    const エントリ: ログエントリ = {
      タイムスタンプ: new Date(),
      レベル: '情報',
      メッセージ,
      データ,
    };
    
    // eslint-disable-next-line no-console
    console.log(ログフォーマット(エントリ));
  },

  /**
   * 警告レベルのログ
   * 注意が必要な状況を記録
   * 
   * @param メッセージ - ログメッセージ
   * @param データ - 追加データ（オプション）
   */
  警告: (メッセージ: string, データ?: unknown): void => {
    const エントリ: ログエントリ = {
      タイムスタンプ: new Date(),
      レベル: '警告',
      メッセージ,
      データ,
    };
    
    // eslint-disable-next-line no-console
    console.warn(ログフォーマット(エントリ));
  },

  /**
   * エラーレベルのログ
   * エラー状況を記録
   * 
   * @param メッセージ - ログメッセージ
   * @param エラー - エラーオブジェクト（オプション）
   * @param データ - 追加データ（オプション）
   */
  エラー: (メッセージ: string, エラー?: Error, データ?: unknown): void => {
    const エントリ: ログエントリ = {
      タイムスタンプ: new Date(),
      レベル: 'エラー',
      メッセージ,
      エラー,
      データ,
    };
    
    let 出力メッセージ = ログフォーマット(エントリ);
    
    // エラーオブジェクトがある場合はスタックトレースも出力
    if (エラー) {
      出力メッセージ += `\nスタックトレース: ${エラー.stack}`;
    }
    
    // eslint-disable-next-line no-console
    console.error(出力メッセージ);
  },
} as const;

/**
 * 初学者向けメモ：ロガーシステムの利点
 * 
 * 1. 一貫性
 *    - 全てのログが同じフォーマットで出力
 *    - 時刻とレベルが自動で付与
 *    - チーム開発時の統一性が向上
 * 
 * 2. 制御可能性
 *    - 環境に応じてログレベルを制御
 *    - 本番環境でのデバッグログ抑制
 *    - パフォーマンスへの影響を最小化
 * 
 * 3. 拡張性
 *    - ファイル出力機能の追加が容易
 *    - 外部ログ収集システムとの連携
 *    - ログローテーションやアーカイブ機能
 * 
 * 4. ESLint対応
 *    - no-console ルールを回避
 *    - 静的解析ツールでの検知が可能
 *    - コードレビューでのチェックが効率化
 */